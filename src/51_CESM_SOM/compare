6c6
< ! !USES:
---
>   ! !USES:
8,16d7
<   use shr_const_mod
<   use shr_sys_mod
<   use shr_kind_mod     , only: IN=>SHR_KIND_IN, R8=>SHR_KIND_R8, &
<                                CS=>SHR_KIND_CS, CL=>SHR_KIND_CL
<   use shr_file_mod     , only: shr_file_getunit, shr_file_getlogunit, shr_file_getloglevel, &
<                                shr_file_setlogunit, shr_file_setloglevel, shr_file_setio, &
<                                shr_file_freeunit
<   use shr_mpi_mod      , only: shr_mpi_bcast
<   use mct_mod
17a9
>   use mct_mod
19,22d10
<   use pio, only : iosystem_desc_t, pio_init, pio_rearr_box
< 
<   use shr_strdata_mod
<   use shr_dmodel_mod
23a12,30
>   use shr_const_mod
>   use shr_sys_mod
>   use shr_kind_mod    , only: IN=>SHR_KIND_IN, R8=>SHR_KIND_R8, CS=>SHR_KIND_CS, CL=>SHR_KIND_CL
>   use shr_file_mod    , only: shr_file_getunit, shr_file_freeunit
>   use shr_mpi_mod     , only: shr_mpi_bcast
>   use shr_frz_mod     , only: shr_frz_freezetemp
>   use shr_strdata_mod , only: shr_strdata_type, shr_strdata_pioinit, shr_strdata_init
>   use shr_strdata_mod , only: shr_strdata_print, shr_strdata_restRead
>   use shr_strdata_mod , only: shr_strdata_advance, shr_strdata_restWrite
>   use shr_dmodel_mod  , only: shr_dmodel_gsmapcreate, shr_dmodel_rearrGGrid
>   use shr_dmodel_mod  , only: shr_dmodel_translate_list, shr_dmodel_translateAV_list, shr_dmodel_translateAV
>   use seq_timemgr_mod , only: seq_timemgr_EClockGetData, seq_timemgr_RestartAlarmIsOn
> 
>   use docn_shr_mod   , only: datamode       ! namelist input
>   use docn_shr_mod   , only: aquap_option   ! derived from datamode namelist input
>   use docn_shr_mod   , only: decomp         ! namelist input
>   use docn_shr_mod   , only: rest_file      ! namelist input
>   use docn_shr_mod   , only: rest_file_strm ! namelist input
>   use docn_shr_mod   , only: nullstr
25,32c32
<   use seq_cdata_mod
<   use seq_infodata_mod
<   use seq_timemgr_mod
<   use seq_comm_mct     , only: seq_comm_inst, seq_comm_name, seq_comm_suffix
<   use seq_flds_mod     , only: seq_flds_o2x_fields, &
<                                seq_flds_x2o_fields
< !
< ! !PUBLIC TYPES:
---
>   ! !PUBLIC TYPES:
36,38c36,38
< !--------------------------------------------------------------------------
< ! Public interfaces
< !--------------------------------------------------------------------------
---
>   !--------------------------------------------------------------------------
>   ! Public interfaces
>   !--------------------------------------------------------------------------
44,46c44,46
< !--------------------------------------------------------------------------
< ! Private data
< !--------------------------------------------------------------------------
---
>   !--------------------------------------------------------------------------
>   ! Private data
>   !--------------------------------------------------------------------------
48,49d47
<   !--- other ---
<   type(iosystem_desc_t), pointer :: iosystem
51,66c49
<   integer(IN)   :: mpicom
<   integer(IN)   :: my_task               ! my task in mpi communicator mpicom
<   integer(IN)   :: npes                  ! total number of tasks
<   integer(IN),parameter :: master_task=0 ! task number of master task
<   integer(IN)   :: logunit               ! logging unit number
<   integer       :: inst_index            ! number of current instance (ie. 1)
<   character(len=16) :: inst_name         ! fullname of current instance (ie. "lnd_0001")
<   character(len=16) :: inst_suffix       ! char string associated with instance 
<                                          ! (ie. "_0001" or "")
<   character(CL) :: ocn_mode              ! mode
<   integer(IN)   :: dbug = 0              ! debug level (higher is more)
<   logical       :: firstcall             ! first call logical
<   logical       :: scmMode = .false.     ! single column mode
<   real(R8)      :: scmLat  = shr_const_SPVAL  ! single column lat
<   real(R8)      :: scmLon  = shr_const_SPVAL  ! single column lon
<   logical       :: read_restart          ! start from restart
---
>   logical       :: firstcall = .true.    ! first call logical
69d51
<   character(len=*),parameter :: nullstr = 'undefined'
71,76c53,58
<   real(R8),parameter :: cpsw    = shr_const_cpsw    ! specific heat of sea h2o ~ J/kg/K
<   real(R8),parameter :: rhosw   = shr_const_rhosw   ! density of sea water ~ kg/m^3
<   real(R8),parameter :: TkFrz   = shr_const_TkFrz   ! freezing point, fresh water (Kelvin)
<   real(R8),parameter :: TkFrzSw = shr_const_TkFrzSw ! freezing point, sea   water (Kelvin)
<   real(R8),parameter :: latice  = shr_const_latice  ! latent heat of fusion
<   real(R8),parameter :: ocnsalt = shr_const_ocn_ref_sal  ! ocean reference salinity
---
>   real(R8),parameter :: cpsw    = shr_const_cpsw        ! specific heat of sea h2o ~ J/kg/K
>   real(R8),parameter :: rhosw   = shr_const_rhosw       ! density of sea water ~ kg/m^3
>   real(R8),parameter :: TkFrz   = shr_const_TkFrz       ! freezing point, fresh water (Kelvin)
>   real(R8),parameter :: TkFrzSw = shr_const_TkFrzSw     ! freezing point, sea   water (Kelvin)
>   real(R8),parameter :: latice  = shr_const_latice      ! latent heat of fusion
>   real(R8),parameter :: ocnsalt = shr_const_ocn_ref_sal ! ocean reference salinity
78,79c60,61
<   integer(IN)   :: kt,ks,ku,kv,kdhdx,kdhdy,kq  ! field indices
<   integer(IN)   :: kswnet,klwup,klwdn,ksen,klat,kmelth,ksnow,kioff
---
>   integer(IN)   :: kt,ks,ku,kv,kdhdx,kdhdy,kq,kswp  ! field indices
>   integer(IN)   :: kswnet,klwup,klwdn,ksen,klat,kmelth,ksnow,krofi
80a63
>   integer(IN)   :: index_lat, index_lon
82,103c65,81
<   type(shr_strdata_type) :: SDOCN
<   type(mct_rearr) :: rearr
<   type(mct_avect) :: avstrm   ! av of data from stream
<   real(R8), pointer :: somtp(:)
<   integer , pointer :: imask(:)
<   character(len=*),parameter :: flds_strm = 'strm_h:strm_qbot'
< 
<   integer(IN),parameter :: ktrans = 28
<   character(12),parameter  :: avifld(1:ktrans) = &
<      (/ "ifrac       ","pslv        ","duu10n      ","taux        ","tauy        ", &
<         "swnet       ","lat         ","sen         ","lwup        ","lwdn        ", &
<         "melth       ","salt        ","prec        ","snow        ","rain        ", &
<         "evap        ","meltw       ","roff        ","ioff        ",                &
<         "t           ","u           ","v           ","dhdx        ","dhdy        ", &
<         "s           ","q           ","h           ","qbot        "                 /)
<   character(12),parameter  :: avofld(1:ktrans) = &
<      (/ "Si_ifrac    ","Sa_pslv     ","So_duu10n   ","Foxx_taux   ","Foxx_tauy   ", &
<         "Foxx_swnet  ","Foxx_lat    ","Foxx_sen    ","Foxx_lwup   ","Faxa_lwdn   ", &
<         "Fioi_melth  ","Fioi_salt   ","Faxa_prec   ","Faxa_snow   ","Faxa_rain   ", &
<         "Foxx_evap   ","Fioi_meltw  ","Forr_roff   ","Forr_ioff   ",                &
<         "So_t        ","So_u        ","So_v        ","So_dhdx     ","So_dhdy     ", &
<         "So_s        ","Fioo_q      ","strm_h      ","strm_qbot   "                 /)
---
>   type(mct_rearr)        :: rearr
>   type(mct_avect)        :: avstrm       ! av of data from stream
>   real(R8), pointer      :: somtp(:)
>   real(R8), pointer      :: tfreeze(:)
>   integer , pointer      :: imask(:)
>   real(R8), pointer      :: xc(:), yc(:) ! arryas of model latitudes and longitudes
> 
>   !--------------------------------------------------------------------------
>   integer(IN)     , parameter :: ktrans = 8
>   character(12)   , parameter :: avifld(1:ktrans) = &
>        (/ "t           ","u           ","v           ","dhdx        ",&
>           "dhdy        ","s           ","h           ","qbot        "/)
>   character(12)   , parameter  :: avofld(1:ktrans) = &
>        (/ "So_t        ","So_u        ","So_v        ","So_dhdx     ",&
>           "So_dhdy     ","So_s        ","strm_h      ","strm_qbot   "/)
>   character(len=*), parameter :: flds_strm = 'strm_h:strm_qbot'
>   !--------------------------------------------------------------------------
107c85
< !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
>   !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
109c87
< !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
>   !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
111,121c89,94
< !===============================================================================
< !BOP ===========================================================================
< !
< ! !IROUTINE: docn_comp_init
< !
< ! !DESCRIPTION:
< !     initialize data ocn model
< !
< ! !REVISION HISTORY:
< !
< ! !INTERFACE: ------------------------------------------------------------------
---
>   !===============================================================================
>   subroutine docn_comp_init(Eclock, x2o, o2x, &
>        seq_flds_x2o_fields, seq_flds_o2x_fields, &
>        SDOCN, gsmap, ggrid, mpicom, compid, my_task, master_task, &
>        inst_suffix, inst_name, logunit, read_restart, &
>        scmMode, scmlat, scmlon)
123c96,97
< subroutine docn_comp_init( EClock, cdata, x2o, o2x, NLFilename )
---
>     ! !DESCRIPTION: initialize docn model
>     use pio        , only : iosystem_desc_t
127,134c101,119
< ! !INPUT/OUTPUT PARAMETERS:
< 
<     type(ESMF_Clock)            , intent(in)    :: EClock
<     type(seq_cdata)             , intent(inout) :: cdata
<     type(mct_aVect)             , intent(inout) :: x2o, o2x
<     character(len=*), optional  , intent(in)    :: NLFilename ! Namelist filename
< 
< !EOP
---
>     ! !INPUT/OUTPUT PARAMETERS:
>     type(ESMF_Clock)       , intent(in)    :: EClock
>     type(mct_aVect)        , intent(inout) :: x2o, o2x            ! input/output attribute vectors
>     character(len=*)       , intent(in)    :: seq_flds_x2o_fields ! fields from mediator
>     character(len=*)       , intent(in)    :: seq_flds_o2x_fields ! fields to mediator
>     type(shr_strdata_type) , intent(inout) :: SDOCN               ! model shr_strdata instance (output)
>     type(mct_gsMap)        , pointer       :: gsMap               ! model global seg map (output)
>     type(mct_gGrid)        , pointer       :: ggrid               ! model ggrid (output)
>     integer(IN)            , intent(in)    :: mpicom              ! mpi communicator
>     integer(IN)            , intent(in)    :: compid              ! mct comp id
>     integer(IN)            , intent(in)    :: my_task             ! my task in mpi communicator mpicom
>     integer(IN)            , intent(in)    :: master_task         ! task number of master task
>     character(len=*)       , intent(in)    :: inst_suffix         ! char string associated with instance
>     character(len=*)       , intent(in)    :: inst_name           ! fullname of current instance (ie. "lnd_0001")
>     integer(IN)            , intent(in)    :: logunit             ! logging unit number
>     logical                , intent(in)    :: read_restart        ! start from restart
>     logical                , intent(in)    :: scmMode             ! single column mode
>     real(R8)               , intent(in)    :: scmLat              ! single column lat
>     real(R8)               , intent(in)    :: scmLon              ! single column lon
137,177c122,126
<     integer(IN)   :: n,k         ! generic counters
<     integer(IN)   :: ierr        ! error code
<     integer(IN)   :: COMPID      ! comp id
<     integer(IN)   :: gsize       ! global size
<     integer(IN)   :: lsize     ! local size
<     integer(IN)   :: shrlogunit, shrloglev ! original log unit and level
<     integer(IN)   :: nunit       ! unit number
<     integer(IN)   :: kmask       ! field reference
<     logical       :: ocn_present    ! flag
<     logical       :: ocn_prognostic ! flag
<     logical       :: ocnrof_prognostic  ! flag
<     character(CL) :: calendar    ! model calendar
< 
<     type(seq_infodata_type), pointer :: infodata
<     type(mct_gsMap)        , pointer :: gsmap
<     type(mct_gGrid)        , pointer :: ggrid
< 
<     character(CL) :: filePath    ! generic file path
<     character(CL) :: fileName    ! generic file name
<     character(CS) :: timeName    ! domain file: time variable name
<     character(CS) ::  lonName    ! domain file: lon  variable name
<     character(CS) ::  latName    ! domain file: lat  variable name
<     character(CS) :: maskName    ! domain file: mask variable name
<     character(CS) :: areaName    ! domain file: area variable name
< 
<     integer(IN)   :: yearFirst   ! first year to use in data stream
<     integer(IN)   :: yearLast    ! last  year to use in data stream
<     integer(IN)   :: yearAlign   ! data year that aligns with yearFirst
< 
<     character(CL) :: ocn_in      ! dshr ocn namelist
<     character(CL) :: decomp      ! decomp strategy
<     character(CL) :: rest_file   ! restart filename
<     character(CL) :: rest_file_strm   ! restart filename for stream
<     character(CL) :: restfilm    ! restart filename for namelist
<     character(CL) :: restfils    ! restart filename for stream for namelist
<     logical       :: exists      ! file existance
<     integer(IN)   :: nu          ! unit number
< 
<     !----- define namelist -----
<     namelist / docn_nml / &
<         ocn_in, decomp, restfilm, restfils
---
>     integer(IN)   :: lsize    ! local size
>     logical       :: exists   ! file existance
>     integer(IN)   :: nu       ! unit number
>     integer(IN)   :: kmask    ! field reference
>     character(CL) :: calendar ! model calendar
180a130
>     character(*), parameter :: F0L   = "('(docn_comp_init) ',a, l2)"
189,190c139
< !-------------------------------------------------------------------------------
< 
---
>     !-------------------------------------------------------------------------------
194,224d142
<     firstcall = .true.
< 
<     ! Set cdata pointers
< 
<     call seq_cdata_setptrs(cdata, ID=COMPID, mpicom=mpicom, &
<          gsMap=gsmap, dom=ggrid, infodata=infodata)
< 
<     ! Determine communicator groups and sizes
< 
<     call mpi_comm_rank(mpicom, my_task, ierr)
<     call mpi_comm_size(mpicom, npes, ierr)
< 
<     inst_name   = seq_comm_name(COMPID)
<     inst_index  = seq_comm_inst(COMPID)
<     inst_suffix = seq_comm_suffix(COMPID)
< 
<     !--- open log file ---
<     if (my_task == master_task) then
<        logUnit = shr_file_getUnit()
<        call shr_file_setIO('ocn_modelio.nml'//trim(inst_suffix),logUnit)
<     else
<        logUnit = 6
<     endif
< 
<     !----------------------------------------------------------------------------
<     ! Reset shr logging to my log file
<     !----------------------------------------------------------------------------
<     call shr_file_getLogUnit (shrlogunit)
<     call shr_file_getLogLevel(shrloglev)
<     call shr_file_setLogUnit (logUnit)
< 
226c144
<     ! Set a Few Defaults
---
>     ! Initialize pio
229,269c147
<     call seq_infodata_getData(infodata,single_column=scmMode, &
<    &                          scmlat=scmlat, scmlon=scmLon)
< 
<     ocn_present = .false.
<     ocn_prognostic = .false.
<     ocnrof_prognostic = .false.
<     call seq_infodata_GetData(infodata,read_restart=read_restart)
< 
<     !----------------------------------------------------------------------------
<     ! Read docn_in
<     !----------------------------------------------------------------------------
< 
<     call t_startf('docn_readnml')
< 
<     filename = "docn_in"//trim(inst_suffix)
<     ocn_in = "unset"
<     decomp = "1d"
<     restfilm = trim(nullstr)
<     restfils = trim(nullstr)
<     if (my_task == master_task) then
<        nunit = shr_file_getUnit() ! get unused unit number
<        open (nunit,file=trim(filename),status="old",action="read")
<        read (nunit,nml=docn_nml,iostat=ierr)
<        close(nunit)
<        call shr_file_freeUnit(nunit)
<        if (ierr > 0) then
<           write(logunit,F01) 'ERROR: reading input namelist, '//trim(filename)//' iostat=',ierr
<           call shr_sys_abort(subName//': namelist read error '//trim(filename))
<        end if
<        write(logunit,F00)' ocn_in = ',trim(ocn_in)
<        write(logunit,F00)' decomp = ',trim(decomp)
<        write(logunit,F00)' restfilm = ',trim(restfilm)
<        write(logunit,F00)' restfils = ',trim(restfils)
<     endif
<     call shr_mpi_bcast(ocn_in,mpicom,'ocn_in')
<     call shr_mpi_bcast(decomp,mpicom,'decomp')
<     call shr_mpi_bcast(restfilm,mpicom,'restfilm')
<     call shr_mpi_bcast(restfils,mpicom,'restfils')
<  
<     rest_file = trim(restfilm)
<     rest_file_strm = trim(restfils)
---
>     call shr_strdata_pioinit(SDOCN, COMPID)
272c150
<     ! Read dshr namelist
---
>     ! Initialize SDOCN
275,281c153
<     call shr_strdata_readnml(SDOCN,trim(ocn_in),mpicom=mpicom)
< 
<     !----------------------------------------------------------------------------
<     ! Validate mode
<     !----------------------------------------------------------------------------
< 
<     ocn_mode = trim(SDOCN%dataMode)
---
>     call t_startf('docn_strdata_init')
283c155
<     ! check that we know how to handle the mode
---
>     call seq_timemgr_EClockGetData( EClock, calendar=calendar )
285,290c157,165
<     if (trim(ocn_mode) == 'NULL' .or. &
<         trim(ocn_mode) == 'SSTDATA' .or. &
<         trim(ocn_mode) == 'COPYALL' .or. &
<         trim(ocn_mode) == 'SOM') then
<       if (my_task == master_task) &
<          write(logunit,F00) ' ocn mode = ',trim(ocn_mode)
---
>     ! NOTE: shr_strdata_init calls shr_dmodel_readgrid which reads the data model
>     ! grid and from that computes SDOCN%gsmap and SDOCN%ggrid. DOCN%gsmap is created
>     ! using the decomp '2d1d' (1d decomp of 2d grid)
> 
>     if (scmmode) then
>        if (my_task == master_task) &
>             write(logunit,F05) ' scm lon lat = ',scmlon,scmlat
>        call shr_strdata_init(SDOCN,mpicom,compid,name='ocn', &
>             scmmode=scmmode,scmlon=scmlon,scmlat=scmlat, calendar=calendar)
292,316c167,169
<       write(logunit,F00) ' ERROR illegal ocn mode = ',trim(ocn_mode)
<       call shr_sys_abort()
<     endif
< 
<     call t_stopf('docn_readnml')
< 
<     !----------------------------------------------------------------------------
<     ! Initialize datasets
<     !----------------------------------------------------------------------------
< 
<     call t_startf('docn_strdata_init')
< 
<     if (trim(ocn_mode) /= 'NULL') then
<        ocn_present = .true.
<        call seq_timemgr_EClockGetData( EClock, calendar=calendar )
<        iosystem => shr_pio_getiosys(trim(inst_name))
<        
<        call shr_strdata_pioinit(SDOCN, iosystem, shr_pio_getiotype(trim(inst_name)))
< 
<        if (scmmode) then
<           if (my_task == master_task) &
<              write(logunit,F05) ' scm lon lat = ',scmlon,scmlat
<           call shr_strdata_init(SDOCN,mpicom,compid,name='ocn', &
<                       scmmode=scmmode,scmlon=scmlon,scmlat=scmlat, &
<                       calendar=calendar)
---
>        if (datamode == 'SST_AQUAPANAL' .or. datamode == 'SST_AQUAPFILE' .or. datamode == 'SOM_AQUAP') then
>           ! Special logic for either prescribed or som aquaplanet - overwrite and
>           call shr_strdata_init(SDOCN,mpicom,compid,name='ocn', calendar=calendar, reset_domain_mask=.true.)
318,324c171,172
<           call shr_strdata_init(SDOCN,mpicom,compid,name='ocn', &
<                       calendar=calendar)
<        endif
<     endif
< 
<     if (trim(ocn_mode) == 'SOM') then
<        ocn_prognostic = .true.
---
>           call shr_strdata_init(SDOCN,mpicom,compid,name='ocn', calendar=calendar)
>        end if
334,342c182
<     ! Set flag to specify data components
<     !----------------------------------------------------------------------------
< 
<     call seq_infodata_PutData(infodata, ocnrof_prognostic=ocnrof_prognostic, &
<       ocn_present=ocn_present, ocn_prognostic=ocn_prognostic, &
<       ocn_nx=SDOCN%nxg, ocn_ny=SDOCN%nyg )
< 
<     !----------------------------------------------------------------------------
<     ! Initialize MCT global seg map, 1d decomp
---
>     ! Initialize data model MCT global seg map, 1d decomp
349,354c189,193
<     call shr_dmodel_gsmapcreate(gsmap,SDOCN%nxg*SDOCN%nyg,compid,mpicom,decomp)
<     lsize = mct_gsmap_lsize(gsmap,mpicom)
< 
<     if (ocn_present) then
<        call mct_rearr_init(SDOCN%gsmap,gsmap,mpicom,rearr)
<     endif
---
>     ! create a data model global seqmap (gsmap) given the data model global grid sizes
>     ! NOTE: gsmap is initialized using the decomp read in from the docn_in namelist
>     ! (which by default is "1d")
>     call shr_dmodel_gsmapcreate(gsmap, SDOCN%nxg*SDOCN%nyg, compid, mpicom, decomp)
>     lsize = mct_gsmap_lsize(gsmap, mpicom)
355a195,196
>     ! create a rearranger from the data model SDOCN%gsmap to gsmap
>     call mct_rearr_init(SDOCN%gsmap, gsmap, mpicom, rearr)
359c200
<     ! Initialize MCT domain
---
>     ! Initialize data model MCT domain
366c207
<     if (ocn_present) call shr_dmodel_rearrGGrid(SDOCN%grid, ggrid, gsmap, rearr, mpicom)
---
>     call shr_dmodel_rearrGGrid(SDOCN%grid, ggrid, gsmap, rearr, mpicom)
386a228
>     kswp  = mct_aVect_indexRA(o2x,'So_fswpen')
399c241
<     kioff  = mct_aVect_indexRA(x2o,'Forr_ioff')
---
>     krofi  = mct_aVect_indexRA(x2o,'Foxx_rofi')
407a250
>     allocate(tfreeze(lsize))
408a252,253
>     allocate(xc(lsize))
>     allocate(yc(lsize))
412a258,263
>     index_lon = mct_aVect_indexRA(ggrid%data,'lon')
>     xc(:) = ggrid%data%rAttr(index_lon,:)
> 
>     index_lat = mct_aVect_indexRA(ggrid%data,'lat')
>     yc(:) = ggrid%data%rAttr(index_lat,:)
> 
420,421c271
<        if (trim(rest_file) == trim(nullstr) .and. &
<            trim(rest_file_strm) == trim(nullstr)) then
---
>        if (trim(rest_file) == trim(nullstr) .and. trim(rest_file_strm) == trim(nullstr)) then
449c299
<        if (trim(ocn_mode) == 'SOM') then
---
>        if (trim(datamode) == 'SOM' .or. trim(datamode) == 'SOM_AQUAP') then
451c301,302
<           call shr_pcdf_readwrite('read',iosystem,SDOCN%io_type,trim(rest_file),mpicom,gsmap,rf1=somtp,rf1n='somtp')
---
>           call shr_pcdf_readwrite('read',SDOCN%pio_subsystem, SDOCN%io_type, &
>                trim(rest_file), mpicom, gsmap=gsmap, rf1=somtp, rf1n='somtp', io_format=SDOCN%io_format)
463c314
<     ! Set initial ocn state, needed for CCSM atm initialization
---
>     ! Set initial ocn state
467c318,320
<     call docn_comp_run( EClock, cdata,  x2o, o2x)
---
>     call docn_comp_run(EClock, x2o, o2x, &
>          SDOCN, gsmap, ggrid, mpicom, compid, my_task, master_task, &
>          inst_suffix, logunit, read_restart)
470,473d322
<     !----------------------------------------------------------------------------
<     ! Reset shr logging to original values
<     !----------------------------------------------------------------------------
< 
477,480d325
<     call shr_file_setLogUnit (shrlogunit)
<     call shr_file_setLogLevel(shrloglev)
<     call shr_sys_flush(logunit)
< 
483c328,336
< end subroutine docn_comp_init
---
>   end subroutine docn_comp_init
> 
>   !===============================================================================
>   subroutine docn_comp_run(EClock, x2o, o2x, &
>        SDOCN, gsmap, ggrid, mpicom, compid, my_task, master_task, &
>        inst_suffix, logunit, read_restart, case_name)
>     use shr_cal_mod, only: shr_cal_ymdtod2string
>     ! !DESCRIPTION:  run method for docn model
>     implicit none
485,651c338,546
< !===============================================================================
< !BOP ===========================================================================
< !
< ! !IROUTINE: docn_comp_run
< !
< ! !DESCRIPTION:
< !     run method for dead ocn model
< !
< ! !REVISION HISTORY:
< !
< ! !INTERFACE: ------------------------------------------------------------------
< 
< subroutine docn_comp_run( EClock, cdata,  x2o, o2x)
< 
<    implicit none
< 
< ! !INPUT/OUTPUT PARAMETERS:
< 
<    type(ESMF_Clock)            ,intent(in)    :: EClock
<    type(seq_cdata)             ,intent(inout) :: cdata
<    type(mct_aVect)             ,intent(inout) :: x2o        ! driver -> dead
<    type(mct_aVect)             ,intent(inout) :: o2x        ! dead   -> driver
< 
< !EOP
< 
<    !--- local ---
<    type(mct_gsMap)        , pointer :: gsmap
<    type(mct_gGrid)        , pointer :: ggrid
< 
<    integer(IN)   :: CurrentYMD        ! model date
<    integer(IN)   :: CurrentTOD        ! model sec into model date
<    integer(IN)   :: yy,mm,dd          ! year month day
<    integer(IN)   :: n                 ! indices
<    integer(IN)   :: nf                ! fields loop index
<    integer(IN)   :: nl                ! ocn frac index
<    integer(IN)   :: lsize           ! size of attr vect
<    integer(IN)   :: shrlogunit, shrloglev ! original log unit and level
<    logical       :: glcrun_alarm      ! is glc going to run now
<    logical       :: newdata           ! has newdata been read
<    logical       :: mssrmlf           ! remove old data
<    integer(IN)   :: idt               ! integer timestep
<    real(R8)      :: dt                ! timestep
<    real(R8)      :: hn                ! h field
<    logical       :: write_restart     ! restart now
<    character(CL) :: case_name         ! case name
<    character(CL) :: rest_file         ! restart_file
<    character(CL) :: rest_file_strm    ! restart_file for stream
<    integer(IN)   :: nu                ! unit number
<    integer(IN)   :: nflds_x2o
<    type(seq_infodata_type), pointer :: infodata
< 
<    character(*), parameter :: F00   = "('(docn_comp_run) ',8a)"
<    character(*), parameter :: F04   = "('(docn_comp_run) ',2a,2i8,'s')"
<    character(*), parameter :: subName = "(docn_comp_run) "
< !-------------------------------------------------------------------------------
< 
<    call t_startf('DOCN_RUN')
< 
<    call t_startf('docn_run1')
< 
<   !----------------------------------------------------------------------------
<   ! Reset shr logging to my log file
<   !----------------------------------------------------------------------------
<    call shr_file_getLogUnit (shrlogunit)
<    call shr_file_getLogLevel(shrloglev)
<    call shr_file_setLogUnit (logUnit)
< 
<    call seq_cdata_setptrs(cdata, gsMap=gsmap, dom=ggrid)
< 
<    call seq_cdata_setptrs(cdata, infodata=infodata)
< 
<    call seq_timemgr_EClockGetData( EClock, curr_ymd=CurrentYMD, curr_tod=CurrentTOD)
<    call seq_timemgr_EClockGetData( EClock, curr_yr=yy, curr_mon=mm, curr_day=dd)
<    call seq_timemgr_EClockGetData( EClock, dtime=idt)
<    dt = idt * 1.0_r8
<    write_restart = seq_timemgr_RestartAlarmIsOn(EClock)
< 
<    call t_stopf('docn_run1')
< 
<    !--------------------
<    ! UNPACK
<    !--------------------
< 
<    call t_startf('docn_unpack')
< 
< !  lsize = mct_avect_lsize(x2o)
< !  nflds_x2o = mct_avect_nRattr(x2o)
< 
< !   do nf=1,nflds_x2o
< !   do n=1,lsize
< !     ?? = x2o%rAttr(nf,n)
< !   enddo
< !   enddo
< 
<    call t_stopf('docn_unpack')
< 
<    !--------------------
<    ! ADVANCE OCN
<    !--------------------
< 
<    call t_barrierf('docn_BARRIER',mpicom)
<    call t_startf('docn')
< 
<    !--- copy all fields from streams to o2x as default ---
< 
<    if (trim(ocn_mode) /= 'NULL') then
<       call t_startf('docn_strdata_advance')
<       call shr_strdata_advance(SDOCN,currentYMD,currentTOD,mpicom,'docn')
<       call t_stopf('docn_strdata_advance')
<       call t_barrierf('docn_scatter_BARRIER',mpicom)
<       call t_startf('docn_scatter')
<       do n = 1,SDOCN%nstreams
<          call shr_dmodel_translateAV(SDOCN%avs(n),o2x,avifld,avofld,rearr)
<       enddo
<       call t_stopf('docn_scatter')
<    else
<       call mct_aVect_zero(o2x)
<    endif
< 
<    call t_startf('docn_mode')
< 
<    select case (trim(ocn_mode))
< 
<    case('COPYALL') 
<       ! do nothing extra
< 
<    case('SSTDATA')
<       lsize = mct_avect_lsize(o2x)
<       do n = 1,lsize
<          o2x%rAttr(kt   ,n) = o2x%rAttr(kt,n) + TkFrz
<          o2x%rAttr(ks   ,n) = ocnsalt
<          o2x%rAttr(ku   ,n) = 0.0_r8
<          o2x%rAttr(kv   ,n) = 0.0_r8
<          o2x%rAttr(kdhdx,n) = 0.0_r8
<          o2x%rAttr(kdhdy,n) = 0.0_r8
<          o2x%rAttr(kq   ,n) = 0.0_r8
<       enddo
< 
<    case('SOM')
<       lsize = mct_avect_lsize(o2x)
<       do n = 1,SDOCN%nstreams
<          call shr_dmodel_translateAV(SDOCN%avs(n),avstrm,avifld,avofld,rearr)
<       enddo
<       if (firstcall) then
<          do n = 1,lsize
<             if (.not. read_restart) then
<                somtp(n) = o2x%rAttr(kt,n) + TkFrz
<             endif
<             o2x%rAttr(kt,n) = somtp(n)
<             o2x%rAttr(kq,n) = 0.0_r8
<          enddo
<       else   ! firstcall
<          do n = 1,lsize
<          if (imask(n) /= 0) then
<             !--- pull out h from av for resuse below ---
<             hn = avstrm%rAttr(kh,n)
<             !--- compute new temp ---
<             o2x%rAttr(kt,n) = somtp(n) + &
<                (x2o%rAttr(kswnet,n) + &  ! shortwave 
<                 x2o%rAttr(klwup ,n) + &  ! longwave
<                 x2o%rAttr(klwdn ,n) + &  ! longwave
<                 x2o%rAttr(ksen  ,n) + &  ! sensible
<                 x2o%rAttr(klat  ,n) + &  ! latent
<                 x2o%rAttr(kmelth,n) - &  ! ice melt
<                 avstrm%rAttr(kqbot ,n) - &  ! flux at bottom
<                 (x2o%rAttr(ksnow,n)+x2o%rAttr(kioff,n))*latice) * &  ! latent by prec and roff
<                 dt/(cpsw*rhosw*hn)
---
>     ! !INPUT/OUTPUT PARAMETERS:
>     type(ESMF_Clock)       , intent(in)    :: EClock
>     type(mct_aVect)        , intent(inout) :: x2o
>     type(mct_aVect)        , intent(inout) :: o2x
>     type(shr_strdata_type) , intent(inout) :: SDOCN
>     type(mct_gsMap)        , pointer       :: gsMap
>     type(mct_gGrid)        , pointer       :: ggrid
>     integer(IN)            , intent(in)    :: mpicom           ! mpi communicator
>     integer(IN)            , intent(in)    :: compid           ! mct comp id
>     integer(IN)            , intent(in)    :: my_task          ! my task in mpi communicator mpicom
>     integer(IN)            , intent(in)    :: master_task      ! task number of master task
>     character(len=*)       , intent(in)    :: inst_suffix      ! char string associated with instance
>     integer(IN)            , intent(in)    :: logunit          ! logging unit number
>     logical                , intent(in)    :: read_restart     ! start from restart
>     character(CL)          , intent(in), optional :: case_name ! case name
> 
>     !--- local ---
>     integer(IN)   :: CurrentYMD            ! model date
>     integer(IN)   :: CurrentTOD            ! model sec into model date
>     integer(IN)   :: yy,mm,dd              ! year month day
>     integer(IN)   :: n                     ! indices
>     integer(IN)   :: lsize                 ! size of attr vect
>     integer(IN)   :: idt                   ! integer timestep
>     real(R8)      :: dt                    ! timestep
>     integer(IN)   :: nu                    ! unit number
>     real(R8)      :: hn                    ! h field
>     logical       :: write_restart         ! restart now
> 
>     real(R8), parameter :: &
>          swp = 0.67_R8*(exp((-1._R8*shr_const_zsrflyr) /1.0_R8)) + 0.33_R8*exp((-1._R8*shr_const_zsrflyr)/17.0_R8)
>     character(len=18) :: date_str
>     character(*), parameter :: F00   = "('(docn_comp_run) ',8a)"
>     character(*), parameter :: F04   = "('(docn_comp_run) ',2a,2i8,'s')"
>     character(*), parameter :: subName = "(docn_comp_run) "
> 
>     !-------------------------------------------------------------------------------
> 
>     call t_startf('DOCN_RUN')
> 
>     call t_startf('docn_run1')
>     call seq_timemgr_EClockGetData( EClock, curr_ymd=CurrentYMD, curr_tod=CurrentTOD)
>     call seq_timemgr_EClockGetData( EClock, curr_yr=yy, curr_mon=mm, curr_day=dd)
>     call seq_timemgr_EClockGetData( EClock, dtime=idt)
>     dt = idt * 1.0_R8
>     write_restart = seq_timemgr_RestartAlarmIsOn(EClock)
>     call t_stopf('docn_run1')
> 
>     !--------------------
>     ! ADVANCE OCN
>     !--------------------
> 
>     call t_barrierf('docn_BARRIER',mpicom)
>     call t_startf('docn')
> 
>     !--- defaults, copy all fields from streams to o2x ---
> 
>     lsize = mct_avect_lsize(o2x)
>     do n = 1,lsize
>        o2x%rAttr(kt   ,n) = TkFrz
>        o2x%rAttr(ks   ,n) = ocnsalt
>        o2x%rAttr(ku   ,n) = 0.0_R8
>        o2x%rAttr(kv   ,n) = 0.0_R8
>        o2x%rAttr(kdhdx,n) = 0.0_R8
>        o2x%rAttr(kdhdy,n) = 0.0_R8
>        o2x%rAttr(kq   ,n) = 0.0_R8
>        o2x%rAttr(kswp ,n) = swp
>     enddo
> 
>     ! NOTE: for SST_AQUAPANAL, the docn buildnml sets the stream to "null"
>     ! and thereby shr_strdata_advance does nothing
> 
>     call t_startf('docn_strdata_advance')
>     call shr_strdata_advance(SDOCN, currentYMD, currentTOD, mpicom, 'docn')
>     call t_stopf('docn_strdata_advance')
> 
>     !--- copy streams to o2x ---
>     call t_barrierf('docn_scatter_BARRIER', mpicom)
>     call t_startf('docn_scatter')
>     do n = 1, SDOCN%nstreams
>        call shr_dmodel_translateAV(SDOCN%avs(n), o2x, avifld, avofld, rearr)
>     enddo
>     call t_stopf('docn_scatter')
> 
>     !-------------------------------------------------
>     ! Determine data model behavior based on the mode
>     !-------------------------------------------------
> 
>     call t_startf('docn_datamode')
>     select case (trim(datamode))
> 
>     case('COPYALL')
>        ! do nothing extra
> 
>     case('SSTDATA')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,lsize
>           o2x%rAttr(kt   ,n) = o2x%rAttr(kt,n) + TkFrz
>           o2x%rAttr(ks   ,n) = ocnsalt
>           o2x%rAttr(ku   ,n) = 0.0_R8
>           o2x%rAttr(kv   ,n) = 0.0_R8
>           o2x%rAttr(kdhdx,n) = 0.0_R8
>           o2x%rAttr(kdhdy,n) = 0.0_R8
>           o2x%rAttr(kq   ,n) = 0.0_R8
>           o2x%rAttr(kswp ,n) = swp
>        enddo
> 
>     case('SST_AQUAPANAL')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,lsize
>           o2x%rAttr(:,n) = 0.0_r8
>        end do
>        call prescribed_sst(xc, yc, lsize, aquap_option, o2x%rAttr(kt,:))
>        do n = 1,lsize
>           o2x%rAttr(kt,n) = o2x%rAttr(kt,n) + TkFrz
>        enddo
> 
>     case('SST_AQUAPFILE')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,lsize
>           o2x%rAttr(kt   ,n) = o2x%rAttr(kt,n) + TkFrz
>           o2x%rAttr(ks   ,n) = ocnsalt
>           o2x%rAttr(ku   ,n) = 0.0_R8
>           o2x%rAttr(kv   ,n) = 0.0_R8
>           o2x%rAttr(kdhdx,n) = 0.0_R8
>           o2x%rAttr(kdhdy,n) = 0.0_R8
>           o2x%rAttr(kq   ,n) = 0.0_R8
>           o2x%rAttr(kswp ,n) = swp
>        enddo
> 
>     case('IAF')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,lsize
>           o2x%rAttr(kt   ,n) = o2x%rAttr(kt,n) + TkFrz
>           o2x%rAttr(ks   ,n) = ocnsalt
>           o2x%rAttr(ku   ,n) = 0.0_R8
>           o2x%rAttr(kv   ,n) = 0.0_R8
>           o2x%rAttr(kdhdx,n) = 0.0_R8
>           o2x%rAttr(kdhdy,n) = 0.0_R8
>           o2x%rAttr(kq   ,n) = 0.0_R8
>           o2x%rAttr(kswp ,n) = swp
>        enddo
> 
>     case('SOM')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,SDOCN%nstreams
>           call shr_dmodel_translateAV(SDOCN%avs(n),avstrm,avifld,avofld,rearr)
>        enddo
>        if (firstcall) then
>           do n = 1,lsize
>              if (.not. read_restart) then
>                 somtp(n) = o2x%rAttr(kt,n) + TkFrz
>              endif
>              o2x%rAttr(kt,n) = somtp(n)
>              o2x%rAttr(kq,n) = 0.0_R8
>           enddo
>        else   ! firstcall
>           tfreeze = shr_frz_freezetemp(o2x%rAttr(ks,:)) + TkFrz
>           do n = 1,lsize
>              if (imask(n) /= 0) then
>                 !--- pull out h from av for resuse below ---
>                 hn = avstrm%rAttr(kh,n)
>                 !--- compute new temp ---
>                 o2x%rAttr(kt,n) = somtp(n) + &
>                      (x2o%rAttr(kswnet,n) + &  ! shortwave
>                      x2o%rAttr(klwup ,n) + &  ! longwave
>                      x2o%rAttr(klwdn ,n) + &  ! longwave
>                      x2o%rAttr(ksen  ,n) + &  ! sensible
>                      x2o%rAttr(klat  ,n) + &  ! latent
>                      x2o%rAttr(kmelth,n) - &  ! ice melt
>                      avstrm%rAttr(kqbot ,n) - &  ! flux at bottom
>                      (x2o%rAttr(ksnow,n)+x2o%rAttr(krofi,n))*latice) * &  ! latent by prec and roff
>                      dt/(cpsw*rhosw*hn)
>                 !--- compute ice formed or melt potential ---
>                 o2x%rAttr(kq,n) = (tfreeze(n) - o2x%rAttr(kt,n))*(cpsw*rhosw*hn)/dt  ! ice formed q>0
>                 o2x%rAttr(kt,n) = max(tfreeze(n),o2x%rAttr(kt,n))                    ! reset temp
>                 somtp(n) = o2x%rAttr(kt,n)                                        ! save temp
>              endif
>           enddo
>        endif   ! firstcall
> 
>     case('SOM_AQUAP')
>        lsize = mct_avect_lsize(o2x)
>        do n = 1,SDOCN%nstreams
>           call shr_dmodel_translateAV(SDOCN%avs(n),avstrm,avifld,avofld,rearr)
>        enddo
>        if (firstcall) then
>           do n = 1,lsize
>              if (.not. read_restart) then
>                 somtp(n) = o2x%rAttr(kt,n) + TkFrz
>              endif
>              o2x%rAttr(kt,n) = somtp(n)
>              o2x%rAttr(kq,n) = 0.0_R8
>           enddo
>        else   ! firstcall
>           tfreeze = shr_frz_freezetemp(o2x%rAttr(ks,:)) + TkFrz
>           do n = 1,lsize
>              !--- pull out h from av for resuse below ---
>              hn = avstrm%rAttr(kh,n)
>              !--- compute new temp ---
>              o2x%rAttr(kt,n) = somtp(n) + &
>                   (x2o%rAttr(kswnet,n) + &  ! shortwave
>                   x2o%rAttr(klwup ,n) + &  ! longwave
>                   x2o%rAttr(klwdn ,n) + &  ! longwave
>                   x2o%rAttr(ksen  ,n) + &  ! sensible
>                   x2o%rAttr(klat  ,n) + &  ! latent
>                   x2o%rAttr(kmelth,n) - &  ! ice melt
>                   avstrm%rAttr(kqbot ,n) - &  ! flux at bottom
>                   (x2o%rAttr(ksnow,n)+x2o%rAttr(krofi,n))*latice) * &  ! latent by prec and roff
>                   dt/(cpsw*rhosw*hn)
653,753c548,839
<             o2x%rAttr(kq,n) = (TkFrzSw - o2x%rAttr(kt,n))*(cpsw*rhosw*hn)/dt  ! ice formed q>0
<             o2x%rAttr(kt,n) = max(TkFrzSw,o2x%rAttr(kt,n))                    ! reset temp
<             somtp(n) = o2x%rAttr(kt,n)                                        ! save temp
<          endif
<          enddo
<       endif   ! firstcall
< 
<    end select
< 
<    call t_stopf('docn_mode')
< 
<    if (write_restart) then
<       call t_startf('docn_restart')
<       call seq_infodata_GetData( infodata, case_name=case_name)
<       write(rest_file,"(2a,i4.4,a,i2.2,a,i2.2,a,i5.5,a)") &
<         trim(case_name), '.docn'//trim(inst_suffix)//'.r.', &
<         yy,'-',mm,'-',dd,'-',currentTOD,'.nc'
<       write(rest_file_strm,"(2a,i4.4,a,i2.2,a,i2.2,a,i5.5,a)") &
<         trim(case_name), '.docn'//trim(inst_suffix)//'.rs1.', &
<         yy,'-',mm,'-',dd,'-',currentTOD,'.bin'
<       if (my_task == master_task) then
<          nu = shr_file_getUnit()
<          open(nu,file=trim(rpfile)//trim(inst_suffix),form='formatted')
<          write(nu,'(a)') rest_file
<          write(nu,'(a)') rest_file_strm
<          close(nu)
<          call shr_file_freeUnit(nu)
<       endif
<       if (trim(ocn_mode) == 'SOM') then
<          if (my_task == master_task) write(logunit,F04) ' writing ',trim(rest_file),currentYMD,currentTOD
<          call shr_pcdf_readwrite('write',iosystem,SDOCN%io_type,trim(rest_file),mpicom,gsmap,clobber=.true., &
<             rf1=somtp,rf1n='somtp')
<       endif
<       if (my_task == master_task) write(logunit,F04) ' writing ',trim(rest_file_strm),currentYMD,currentTOD
<       call shr_strdata_restWrite(trim(rest_file_strm),SDOCN,mpicom,trim(case_name),'SDOCN strdata')
<       call shr_sys_flush(logunit)
<       call t_stopf('docn_restart')
<    endif
< 
<    call t_stopf('docn')
< 
<    !----------------------------------------------------------------------------
<    ! Log output for model date
<    ! Reset shr logging to original values
<    !----------------------------------------------------------------------------
< 
<    call t_startf('docn_run2')
<    if (my_task == master_task) then
<       write(logunit,F04) trim(myModelName),': model date ', CurrentYMD,CurrentTOD
<       call shr_sys_flush(logunit)
<    end if
<    firstcall = .false.
<       
<    call shr_file_setLogUnit (shrlogunit)
<    call shr_file_setLogLevel(shrloglev)
<    call shr_sys_flush(logunit)
<    call t_stopf('docn_run2')
< 
<    call t_stopf('DOCN_RUN')
< 
< end subroutine docn_comp_run
< 
< !===============================================================================
< !BOP ===========================================================================
< !
< ! !IROUTINE: docn_comp_final
< !
< ! !DESCRIPTION:
< !     finalize method for dead ocn model
< !
< ! !REVISION HISTORY:
< !
< ! !INTERFACE: ------------------------------------------------------------------
< !
< subroutine docn_comp_final()
< 
<    implicit none
< 
< !EOP
< 
<    !--- formats ---
<    character(*), parameter :: F00   = "('(docn_comp_final) ',8a)"
<    character(*), parameter :: F91   = "('(docn_comp_final) ',73('-'))"
<    character(*), parameter :: subName = "(docn_comp_final) "
<    integer :: rcode
< !-------------------------------------------------------------------------------
< !
< !-------------------------------------------------------------------------------
< 
<    call t_startf('DOCN_FINAL')
<    if (my_task == master_task) then
<       write(logunit,F91) 
<       write(logunit,F00) trim(myModelName),': end of main integration loop'
<       write(logunit,F91) 
<    end if
<       
<    call t_stopf('DOCN_FINAL')
< 
< end subroutine docn_comp_final
< !===============================================================================
< !===============================================================================
---
>              o2x%rAttr(kq,n) = (tfreeze(n) - o2x%rAttr(kt,n))*(cpsw*rhosw*hn)/dt  ! ice formed q>0
>              somtp(n) = o2x%rAttr(kt,n)                                        ! save temp
>           enddo
>        endif   ! firstcall
> 
>     end select
> 
>     call t_stopf('docn_datamode')
> 
>     !--------------------
>     ! Write restart
>     !--------------------
> 
>     if (write_restart) then
>        call t_startf('docn_restart')
>        call shr_cal_ymdtod2string(date_str, yy,mm,dd,currentTOD)
>        write(rest_file,"(6a)") &
>             trim(case_name), '.docn',trim(inst_suffix),'.r.', &
>             trim(date_str),'.nc'
>        write(rest_file_strm,"(6a)") &
>             trim(case_name), '.docn',trim(inst_suffix),'.rs1.', &
>             trim(date_str),'.bin'
>        if (my_task == master_task) then
>           nu = shr_file_getUnit()
>           open(nu,file=trim(rpfile)//trim(inst_suffix),form='formatted')
>           write(nu,'(a)') rest_file
>           write(nu,'(a)') rest_file_strm
>           close(nu)
>           call shr_file_freeUnit(nu)
>        endif
>        if (trim(datamode) == 'SOM' .or. trim(datamode) == 'SOM_AQUAP') then
>           if (my_task == master_task) write(logunit,F04) ' writing ',trim(rest_file),currentYMD,currentTOD
>           call shr_pcdf_readwrite('write', SDOCN%pio_subsystem, SDOCN%io_type,&
>                trim(rest_file), mpicom, gsmap, clobber=.true., rf1=somtp,rf1n='somtp')
>        endif
>        if (my_task == master_task) write(logunit,F04) ' writing ',trim(rest_file_strm),currentYMD,currentTOD
>        call shr_strdata_restWrite(trim(rest_file_strm), SDOCN, mpicom, trim(case_name), 'SDOCN strdata')
>        call shr_sys_flush(logunit)
>        call t_stopf('docn_restart')
>     endif
> 
>     call t_stopf('docn')
> 
>     !----------------------------------------------------------------------------
>     ! Log output for model date
>     !----------------------------------------------------------------------------
> 
>     call t_startf('docn_run2')
>     if (my_task == master_task) then
>        write(logunit,F04) trim(myModelName),': model date ', CurrentYMD,CurrentTOD
>        call shr_sys_flush(logunit)
>     end if
> 
>     firstcall = .false.
>     call t_stopf('docn_run2')
> 
>     call t_stopf('DOCN_RUN')
> 
>   end subroutine docn_comp_run
> 
>   !===============================================================================
>   subroutine docn_comp_final(my_task, master_task, logunit)
> 
>     ! !DESCRIPTION:  finalize method for docn model
>     implicit none
> 
>     ! !INPUT/OUTPUT PARAMETERS:
>     integer(IN) , intent(in) :: my_task     ! my task in mpi communicator mpicom
>     integer(IN) , intent(in) :: master_task ! task number of master task
>     integer(IN) , intent(in) :: logunit     ! logging unit number
> 
>     !--- formats ---
>     character(*), parameter :: F00   = "('(docn_comp_final) ',8a)"
>     character(*), parameter :: F91   = "('(docn_comp_final) ',73('-'))"
>     character(*), parameter :: subName = "(docn_comp_final) "
>     !-------------------------------------------------------------------------------
> 
>     call t_startf('DOCN_FINAL')
> 
>     if (my_task == master_task) then
>        write(logunit,F91)
>        write(logunit,F00) trim(myModelName),': end of main integration loop'
>        write(logunit,F91)
>     end if
> 
>     call t_stopf('DOCN_FINAL')
> 
>   end subroutine docn_comp_final
> 
>   !===============================================================================
>   subroutine prescribed_sst(xc, yc, lsize, sst_option, sst)
> 
>     real(R8)     , intent(in)    :: xc(:)  !degrees
>     real(R8)     , intent(in)    :: yc(:)  !degrees
>     integer(IN)  , intent(in)    :: lsize
>     integer(IN)  , intent(in)    :: sst_option
>     real(R8)     , intent(inout) :: sst(:)
> 
>     ! local
>     integer  :: i
>     real(r8) :: tmp, tmp1, pi
>     real(r8) :: rlon(lsize), rlat(lsize)
> 
>     real(r8), parameter :: pio180 = SHR_CONST_PI/180._r8
> 
>     ! Parameters for zonally symmetric experiments
>     real(r8), parameter ::   t0_max     = 27._r8
>     real(r8), parameter ::   t0_min     = 0._r8
>     real(r8), parameter ::   maxlat     = 60._r8*pio180
>     real(r8), parameter ::   shift      = 5._r8*pio180
>     real(r8), parameter ::   shift9     = 10._r8*pio180
>     real(r8), parameter ::   shift10    = 15._r8*pio180
> 
>     ! Parameters for zonally asymmetric experiments
>     real(r8), parameter ::   t0_max6    = 1._r8
>     real(r8), parameter ::   t0_max7    = 3._r8
>     real(r8), parameter ::   latcen     = 0._r8*pio180
>     real(r8), parameter ::   loncen     = 0._r8*pio180
>     real(r8), parameter ::   latrad6    = 15._r8*pio180
>     real(r8), parameter ::   latrad8    = 30._r8*pio180
>     real(r8), parameter ::   lonrad     = 30._r8*pio180
>     !-------------------------------------------------------------------------------
> 
>     pi = SHR_CONST_PI
> 
>     ! convert xc and yc from degrees to radians
> 
>     rlon(:) = xc(:) * pio180
>     rlat(:) = yc(:) * pio180
> 
>     ! Control
> 
>     if (sst_option < 1 .or. sst_option > 10) then
>        call shr_sys_abort ('prescribed_sst: ERROR: sst_option must be between 1 and 10')
>     end if
> 
>     if (sst_option == 1 .or. sst_option == 6 .or. sst_option == 7 .or. sst_option == 8) then
>        do i = 1,lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else
>              tmp = sin(rlat(i)*pi*0.5_r8/maxlat)
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
> 
>     ! Flat
> 
>     if (sst_option == 2) then
>        do i = 1,lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else
>              tmp = sin(rlat(i)*pi*0.5_r8/maxlat)
>              tmp = 1._r8 - tmp*tmp*tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
> 
>     ! Qobs
> 
>     if (sst_option == 3) then
>        do i = 1,lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else
>              tmp = sin(rlat(i)*pi*0.5_r8/maxlat)
>              tmp = (2._r8 - tmp*tmp*tmp*tmp - tmp*tmp)*0.5_r8
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
> 
>     ! Peaked
> 
>     if (sst_option == 4) then
>        do i = 1,lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else
>              tmp = (maxlat - abs(rlat(i)))/maxlat
>              tmp1 = 1._r8 - tmp
>              sst(i) = t0_max*tmp + t0_min*tmp1
>           end if
>        end do
>     end if
> 
>     ! Control-5N
> 
>     if (sst_option == 5) then
>        do i = 1,lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else if (rlat(i) > shift) then
>              tmp = sin((rlat(i)-shift)*pi*0.5_r8/(maxlat-shift))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           else
>              tmp = sin((rlat(i)-shift)*pi*0.5_r8/(maxlat+shift))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
> 
>     ! 1KEQ
> 
>     if (sst_option == 6) then
>        do i = 1,lsize
>           if (abs(rlat(i)-latcen) <= latrad6) then
>              tmp1 = cos((rlat(i)-latcen)*pi*0.5_r8/latrad6)
>              tmp1 = tmp1*tmp1
>              tmp = abs(rlon(i)-loncen)
>              tmp = min(tmp , 2._r8*pi-tmp)
>              if(tmp <= lonrad) then
>                 tmp = cos(tmp*pi*0.5_r8/lonrad)
>                 tmp = tmp*tmp
>                 sst(i) = sst(i) + t0_max6*tmp*tmp1
>              end if
>           end if
>        end do
>     end if
> 
>     ! 3KEQ
> 
>     if (sst_option == 7) then
>        do i = 1, lsize
>           if (abs(rlat(i)-latcen) <= latrad6) then
>              tmp1 = cos((rlat(i)-latcen)*pi*0.5_r8/latrad6)
>              tmp1 = tmp1*tmp1
>              tmp = abs(rlon(i)-loncen)
>              tmp = min(tmp , 2._r8*pi-tmp)
>              if (tmp <= lonrad) then
>                 tmp = cos(tmp*pi*0.5_r8/lonrad)
>                 tmp = tmp*tmp
>                 sst(i) = sst(i) + t0_max7*tmp*tmp1
>              end if
>           end if
>        end do
>     end if
> 
>     ! 3KW1
> 
>     if (sst_option == 8) then
>        do i = 1, lsize
>           if (abs(rlat(i)-latcen) <= latrad8) then
>              tmp1 = cos((rlat(i)-latcen)*pi*0.5_r8/latrad8)
>              tmp1 = tmp1*tmp1
>              tmp = cos(rlon(i)-loncen)
>              sst(i) = sst(i) + t0_max7*tmp*tmp1
>           end if
>        end do
>     end if
> 
>     ! Control-10N
> 
>     if (sst_option == 9) then
>        do i = 1, lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else if (rlat(i) > shift9) then
>              tmp = sin((rlat(i)-shift9)*pi*0.5_r8/(maxlat-shift9))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           else
>              tmp = sin((rlat(i)-shift9)*pi*0.5_r8/(maxlat+shift9))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
> 
>     ! Control-15N
> 
>     if (sst_option == 10) then
>        do i = 1, lsize
>           if (abs(rlat(i)) > maxlat) then
>              sst(i) = t0_min
>           else if(rlat(i) > shift10) then
>              tmp = sin((rlat(i)-shift10)*pi*0.5_r8/(maxlat-shift10))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           else
>              tmp = sin((rlat(i)-shift10)*pi*0.5_r8/(maxlat+shift10))
>              tmp = 1._r8 - tmp*tmp
>              sst(i) = tmp*(t0_max - t0_min) + t0_min
>           end if
>        end do
>     end if
754a841
>   end subroutine prescribed_sst
